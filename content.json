{"pages":[],"posts":[{"title":"","text":"JavaScript Decoratorsdecorators 是什么decorators是在ES7中的概念，可以把它当成一个容器作用在目标函数和类上，然后对它做一系列操作返回一个新的函数和类。 1234@somethingfunction doing(){ ...} 我们上面使用装饰器作用在了doing函数上，上面的形式其实可以理解成下面这样 1234let doing = function (){ ...}doing = something(doing) 这里我们把doing函数传入了something函数然后返回一新的doing函数，这个新的doing函数经过something的处理已经添加了一些新的行为。 使用 decorators环境因为decorators是ES7的语法我们需要使用babel插件： 安装 @babel/plugin-proposal-decorators1yarn add @babel/plugin-proposal-decorators 配置1234567891011// package.json&quot;babel&quot;: { &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true } ] ]} 这样就可以在项目中使用装饰器了 定义作用在函数定义作用在函数上的装饰器，使用的是ES5的Object.defineProperty 方法，通过控制对象属性描述符来处理函数。 1Object.defineProperty(obj, prop, descriptor) Object.defineProperty方法接受三个参数： 目标对象 属性名 属性的描述符 装饰器就是让我们通过操作上述的变量来处理当前属性。 12345678910111213function something (obj,prop,descriptor){ let _value = descriptor.value; descriptor.value = function () { ... // 操作一 _value() ...// 操作二 }}@somethingfunction doing(){ ...} 我们在doing函数上加了装饰器something，并且在原来函数之前增加了操作一，之后增加了操作二，形成了一个新的函数。我们也可以修改其他属性描述符如writabled修改它的可读性，等等。 作用在类作用在类上比较简单就是传入了类本身，我们通过修改类的prototype对象来处理类。 12345678910111213141516171819202122232425262728293031323334import Immutable from 'immutable'function shouldComponentDecorators(target) { const compareEqual = function (objA, objB) { if (objA === objB || Immutable.is(objA, objB)) { return true } if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) { return false; } const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) { return false; } for (let i = 0; i &lt; keysA.length; i++) { if (keysB.indexOf(keysA[i]) === -1) { return false; } if (!Immutable.is(objA[keysA[i]], objB[keysA[i]])) { return false } } return true }; target.prototype.shouldComponentUpdate = function (nextProps, nextState, nextContext) { return !compareEqual(this.state, nextState) || !compareEqual(this.props, nextProps) }} 上面就实现了一个给react组件添加shouldComponentUpdate生命周期方法的装饰器，在使用是只需要在创建react类前面增加@shouldComponentDecorators就可给它增加十分方便。 增加参数我们可能需要同一个装饰器不同情况下有所差异或者一些定制化值，可以通过传递参数实现 12345678910111213141516171819@something(true)// 函数function something (value){ return function(target, key, descriptor) { descriptor.value = function () { if(value) ... // 操作一 else ... // 操作二 _value() } }}// 类function something (value){ return function(target) { target.prototype.value= value }} 场景decorators 能使用的场景很多如封装常用操作，封装重复代码，权限控制，路由等等。目前有个 core-decorators （https://github.com/jayphelps/core-decorators）库已经定义类很多有用的装饰器。我们在日常开发中可以总结提取出自己的装饰器库，可以有效的提升开发体验。 总结ES7新加入的装饰器特性可以让我们简化代码，增加复用，增加代码的可维护性。","link":"/2019/10/30/JavaScriptDecortors/"},{"title":"","text":"Async Javascript And XML前端开发的里程碑，翻开了Web开发的新篇章。基于 AJAX，我们可以把 Web 分为前端和后端，前端负责界面和交互，后端负责业务逻辑的处理，从原来全部由后端处理业务逻辑逐渐开始像前端迁移，也就有了前端开发工程师的职位。 历史 1999年IE 5首先引入了ActiveX对象可以通过js发送请求实现页面刷新 其他游览器也纷纷引入，取名XMLHttpRequest。 由于各个游览器实现标准不统一， W3C统一并纳入规范。 2005年，Garrett 提出ajax一词，ajax技术进入大众视野。 2008年W3C 提出了XMLHttpRequest Level 2 草案，进行了优化和改进。 XMLHttpRequest Level 2 XMLHttpRequest游览器实现的内置对象，可以通过它进行HTTP通信。也就是我们实现Ajax（Async Javascript And XML）的关键。 使用新建实例1const xhr = new XMLHttpRequest(); 发送请求12xhr.open('GET', 'https://testfund.10jqka.com.cn/ifundtools/add'); xhr.send(); 等待响应1234567xhr.onreadystatechange = function(){ if ( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ) { console.log( xhr.responseText ); } else { console.log( xhr.statusText ); } }; readystate readystate 状态 描述 0 UNSENT（未打开） open()方法还未被调用 1 OPENED（未发送） open()方法已经被调用 2 HEADERS_RECEIVED（已获取响应头） end()方法已经被调用，响应头和响应状态已经返回 3 LOADING（正在下载响应体） 响应体下载中;responseText中已经获取了部分数据 4 DONE（请求完成） 整个请求过程已经完毕 XMLHttpRequest Level 1 缺点最早的方案随着需求发展有了很多不足： 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提示有没有完成。 受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据。 XMLHttpRequest Level 2 新增通过新增功能lai 可以设置HTTP请求的时限。 可以使用FormData对象管理表单数据。 可以上传文件。 可以请求不同域名下的数据（跨域请求）。 可以获取服务器端的二进制数据。 可以获得数据传输的进度信息。 超时时间可以设置超时时间，请求超过设置时间时就会取消 1234xhr.timeout = 1000;xhr.ontimeout = function(event){ console.log('请求超时'); } 超过1000ms就会取消请求，并输出’请求超时’。 FormDataXMLHttpRequest Level 2允许我们模拟表单提交和后台交互数据。 网络请求中处理表单数据 网络请求中处理用来异步的上传文件 表单提交类型我们通过HTTP和后端表单交互数据时一般content-type会有2种： application/x-www-form-urlencoded multipart/form-data application/x-www-form-urlencoded使用表单post提交时，content-type默认会使用application/x-www-form-urlencoded, 请求数据会使用url编码成key/value对，封装到body中传输给后端。 multipart/form-data如果需要提交文件上传时，必须要将content-type设置为multipart/form-data，因为application/x-www-form-urlencoded会使用url编码，这样无法将二进制文件或者包含非ASCII字符的数据进行编码传输。 这里可以看到，如果content-type设置为multipart/form-data时将对body使用content-type中boundary的值对内容进行了分割，每个部分都有一个content-desposition头，其中说明了字段名、类型，默认为text/plain，会根据上传的内容自动变化，比如这里我们上传了一个json文件，content-type类型就变成了application/json，后面就跟着该字段的具体的值。 模拟提交123var formData = new FormData();formData.append('name', 'ifund'); formData.append('age', 10); CORS可以向不同域名的服务器发出HTTP请求，但需要服务器设置响应头才能相应成功。 通过设置： Access-Control-Allow-Headers Access-Control-Allow-Methods Access-Control-Allow-Origin 等字段允许跨域并设置相应条件。 执行事件通过事件来获取到当前上传下载进度。 abort：取消 error：出现错误 loadstart：开始传输 progress：传输过程 load：传输完成 loadEnd：传输结束12345678910xhr.onprogress = (event) =&gt; { if (event.lengthComputable) { console.log(event.loaded / event.total) } }xhr.onload = (event) =&gt; { if (event.lengthComputable) { console.log(&quot;传输完成&quot;) } } 设置接受数据类型通过设置responseType指定接受类型。 arraybuffer：是一个包含二进制数据的 JavaScript ArrayBuffer。 blob：response是一个包含二进制数据的 Blob 对象 。 document：response 是一个 HTML Document 或 XML XMLDocument，这取决于接收到的数据的 MIME 类型 json：response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为 JSON 解析得到的。 text：response 是一个以 DOMString 对象表示的文本。（DOMString 是一个UTF-16字符串） 当将responseType设置为一个特定的类型时，你需要确保服务器所返回的类型和你所设置的返回值类型是兼容的。那么如果两者类型不兼容，服务器返回的数据会变成了null，即使服务器返回了数据。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;img&quot;&gt; &lt;a id=&quot;download&quot;&gt;下载&lt;/a&gt;&lt;/body&gt;&lt;script&gt; let xhr = new XMLHttpRequest(); xhr.open('get', 'https://s.thsi.cn/ijijin/image/ifundtrade/i-search.png'); xhr.responseType = 'blob'; xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { let url = window.URL.createObjectURL(xhr.response); document.getElementById('img').src = url; document.getElementById('download').href = url; document.getElementById('download').download = 'a.png' } }; xhr.send()&lt;/script&gt;&lt;/html&gt; axiosAxios 是一个基于 Promise 的 HTTP请求库，同时支持浏览器和 Node.js 环境。由于其简单易用的特点，现在游览器处理ajax请求普遍使用axios, github已经有78.4k的star。我们接下来从源码中剖析axios实现原理。 拦截器我们从拦截器这一特性进入axios源码，解析器内部流程。 类型 请求拦截器：在请求发送前执行，可以修改请求参数，headers等信息。 响应拦截器：在接收到响应执行，可以对某些特殊相应做处理，比如重定向。 使用12345678910// 请求拦截axios.interceptors.request.use(function (config) { console.log(config) return config;}); // 相应拦截axios.interceptors.respond.use(function (config) { console.log(config) return config;}); 源码分析入口文件 /lib/axios.js 1234567function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); utils.extend(instance, Axios.prototype, context); utils.extend(instance, context); return instance;} 我们平时使用时 import axios 所抛出的实例就是createInstance这个方法的返回值，这里看到实例是从Axios构建而来。 /lib/core/Axios.js 1234567function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };} Axios的构建函数十分简单，声明了defaults和interceptors两个属性，其中defaults就是默认的配置和我们新建实例时传入对象合并生成的对象 /lib/default.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var defaults = { // 区分node和游览器环境返回最用的请求对象 adapter: getDefaultAdapter(), // 请求前执行方法 transformRequest: [function transformRequest(data, headers) { normalizeHeaderName(headers, 'Accept'); normalizeHeaderName(headers, 'Content-Type'); if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data) ) { return data; } if (utils.isArrayBufferView(data)) { return data.buffer; } if (utils.isURLSearchParams(data)) { setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'); return data.toString(); } if (utils.isObject(data)) { setContentTypeIfUnset(headers, 'application/json;charset=utf-8'); return JSON.stringify(data); } return data; }], // 响应后执行方法 transformResponse: [function transformResponse(data) { /*eslint no-param-reassign:0*/ if (typeof data === 'string') { try { data = JSON.parse(data); } catch (e) { /* Ignore */ } } return data; }], // 超时时间 timeout: 0, // csrf 防范，axios会使用双重验证防范（cookies和头部字段验证） xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, maxBodyLength: -1, // 成功状态吗 validateStatus: function validateStatus(status) { return status &gt;= 200 &amp;&amp; status &lt; 300; }}; 上面这些配置我们都是可以通过axios.create方法来覆盖。 声明的另外一个属性就是拦截器，我们看下拦截器的构造函数。/lib/core/InterceptorManager.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445'use strict';var utils = require('./../utils');/** * 构造函数本身十分简单，只有一个handlers属性，它是记录拦截器执行的函数和顺序。 */function InterceptorManager() { this.handlers = [];}/** * 我们注册拦截器的时候用的就是这个方法，可以看到我们将我们传入的拦截函数push到了handlers * 中，并且返回了当前注册的拦截器id。 */InterceptorManager.prototype.use = function use(fulfilled, rejected) { this.handlers.push({ fulfilled: fulfilled, rejected: rejected }); return this.handlers.length - 1;};/** * 通过注册时返回的拦截器id可以删除注册的拦截器。 */InterceptorManager.prototype.eject = function eject(id) { if (this.handlers[id]) { this.handlers[id] = null; }};/** * 遍历handlers并将每个拦截器作为参数传入fn中 */InterceptorManager.prototype.forEach = function forEach(fn) { utils.forEach(this.handlers, function forEachHandler(h) { if (h !== null) { fn(h); } });};module.exports = InterceptorManager; 上面我们通过InterceptorManager生成了拦截器实例并注册了拦截器，有注册就会有调用，具体调用就是在request方法，axios所有的请求都是调用这个方法。 /lib/core/Axios.js 12345678910111213141516171819 Axios.prototype.request = function request(config) { // ................. // 设置调用链表 var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); // 获取注册的请求拦截器 this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected); }); // 获取注册的响应拦截器 this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected); }); // 设置调用顺序 while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); } return promise;}); chain是我们最后的调用链表，最后我们会依次执行chain其中的函数，每两个为一对，第一个是resolve方法，第二个是reject方法，通过在他前面和后面添加拦截器函数来实现请求拦截和响应拦截。链表中默认有 dispatchRequest 这个方法，这里面就是我们实际上发送请求的函数。 /lib/core/dispatchRequest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 最后实际发送请求的方法module.exports = function dispatchRequest(config) { throwIfCancellationRequested(config); // 设置头部 config.headers = config.headers || {}; // 格式化请求数据 config.data = transformData( config.data, config.headers, config.transformRequest ); // 合并请求头 config.headers = utils.merge( config.headers.common || {}, config.headers[config.method] || {}, config.headers ); utils.forEach( ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) { delete config.headers[method]; } ); // 获取请求对象 如果是在游览器中则是xhr对象 具体在/lib/adapters/xhr中 var adapter = config.adapter || defaults.adapter; // 发送请求 return adapter(config).then(function onAdapterResolution(response) { throwIfCancellationRequested(config); // 格式化响应数据 response.data = transformData( response.data, response.headers, config.transformResponse ); return response; }, function onAdapterRejection(reason) { if (!isCancel(reason)) { throwIfCancellationRequested(config); if (reason &amp;&amp; reason.response) { reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); } } return Promise.reject(reason); });}; 整个axios调用链路到这里就结束，这里只是概括了axios的主要流程，具体可以自己查看axios源码，并不复杂。","link":"/2020/11/03/%E6%B7%B1%E5%85%A5AJAX%E5%92%8Caxios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"","text":"深入JavaScript类型转换总所周知javascript是一门弱类型语言，这为我们提供了灵活行、简易性，但有时也给我们出乎意料结果，其中最多的就是类型转换。类型转换我们通常意义上分为两种，显式类型转换和隐式类型转换。这两种并没有明确的划分，通常取决于转换的隐蔽性。如果我们不理解类型转化将如何发生，可能会出现意料之外的情况，但是如果我们理解了所有的转换情况那么在我们眼里任何转换就都是显式转换。 抽象操作要去理解类型转换首先要知道各个类型的转化的基础规则，在ES5中定义了一些抽象操作（仅供内部使用的操作） ToString非字符串类型至字符串类型的转换 基础类型: null -&gt; “null” undefined -&gt; ‘undefined’ true -&gt; ‘true’ 100 -&gt; ‘100’ 引用类型: 普通对象会返回内部书香[[class]]（内部的分类）的值 {} -&gt; [object Object]可通过[[class]]判断数据类型123Object.prototype.toString.call([],null) // &quot;[object Array]&quot;Object.prototype.toString.call(Symbol('wangzyer'),null) // &quot;[object Symbol]&quot; 数组默认每一项用“，”拼接 【1，2，3】-&gt; “1，2，3” ToNumber非数字类型至数字类型的转化 基础类型: true -&gt; 1 false -&gt; 0 null -&gt; 0 undefined -&gt; NaN string “123” -&gt; 123 “123a” -&gt; NaN 引用类型: 首先会被转化为基础类型，然后根据基础类型的转化规则转化 ToBoolean非布尔类型至布尔类型的转换 假值 undefined null false 0 +0 -0 NaN “” 真值 假值以外的值都是真值 ToPrimitive对象到基础类型的转化 首先调用对象valueOf方法 判断valueOf方法的返回值是不是基础类型，如果是则转化完成 如果valueOf方法返回值不是基础类型则调用toString方法 类型之间转化类型转化通常是： Object -&gt; 基础类型 基础类型 -&gt; 基础类型 * -&gt; Numberssss +false ~ ~{} Number() * -&gt; String转化成字符串相对比较简单 false.toString() String(false) false + ‘’ * -&gt; Boolean !1 Boolean() if(…) for(…;…;…) ？： while(…) do…while(…) || &amp;&amp; 左边的表达式 数字和字符串之间转换数字和字符串之间的转化应该我们平时最常见的转化，所以单独提出来总结一下。 Number -&gt; String数字转化成字符串的： String(1) 根据抽象操作的ToString规则 1..toString() new Date(1571239714845) 1 + ‘’ String -&gt; Number Number() 遵循抽象操作的ToNumber规则 parseInt()、parseFloat() ~’123’ +or-‘123’ new Date(‘2019/10/16’) 解析速度parseInt &gt; parseFloat &gt; Number parseInt和parseFloat是只处理字符串，任何不是字符串的值都会先转成字符串包括数字，然后在根据规则解析字符串最后返回数字，流程相对简单，并做了目的性强的优化，所以处理速度快。 Number构造函数会首先判断类型然后根据不同类型在做相应的转化，这里耗费的比较多时间，但是这些时间的耗费都是微妙级的。 Object -&gt; *对像转化成基础类根据ToPrimitive规则。toPrimitive操作会获取对象的[[Default]]。通常就是先调用valueOf()方法判断返回的时候是基础类型，是则返回，不是则调用toString()方法 123456let a = { valueOf(){ return 1 }}a + '' // '1' 在上述运算中首先需要对象a转化为基础类型，返回了1，在 1 + ‘’，返回了 ’1‘。 宽松相等和严格相等宽松相等与严格相等的区别是严格相等比较过程中不允许类型转换，宽松相等做的事情其实比严格相等更多，但是相差的时间都是几微秒。 在平时开发过程中推荐使用严格相等，使用宽松相等场景并不是很多。我平时写业务代码与后端数据交互时，返回“数字”的类型是不明确的这时我更多时使用Number类型转化一下，这样在未来阅读代码时候类型就很明确了。 宽松相等两种类型不同值比较时会将两边转化成同类型在进行比较，这里我们最主要的就是弄清楚各个类型比较时转化的规则 非常规情况 NaN == NaN false 不与任何值相等包括自己 -0 == +0 true null == undefined true Number和String之前比较1.使用ToNumber规则将字符串转化为数字2.数字之间比较 其中一方有Boolean1.首先将Boolean转化为数字 false-&gt;0 true-&gt;12.在比较两边类型是否相等，不同类型在进行转化比较。 对象和非对象之间的比较 首相将对象转化为基础类型，遵循ToPrimitive 在比较两边类型是否相等，不同类型在进行转化比较。 难点比较中出现false一般在比较中出现了false的情况就比较难以理解，我们在宽松相等中看到false要记得他会转化成数字类型。 “0” == false truefalse -&gt; 0“0” -&gt; 0 false == ‘’ truefalse -&gt; 0‘’ -&gt; 0 比较中出现对象 false == [] truefalse -&gt; 0[].valueOf() -&gt; [][].toString -&gt; ‘’‘’ -&gt; 0 “” == [] // true[].valueOf() -&gt; [][].toString -&gt; ‘’","link":"/2020/10/15/%E6%B7%B1%E5%85%A5JavaScript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"","text":"游览器基本工作原理(chrome)游览器的使用十分简单，输入url页面呈现出来。但是这背后的资源请求是如何协调请求的、页面是如何渲染的、游览器内部是如何工作的都是一个前端应该知道的。 浏览器的多进程架构模块化是我们项目结构中比较重要的一个概念，各个模块负责不同功能，各个模块通过抛出方法和数据对外交互，各个模块相互调用组合构成系统。游览器结构也是如此，把不同的职责分配个各个进程（线程），通过主要进程（线程）分发任务、收集数据实现功能。下面列举了几个核心模块的交互和功能： Browser Process：负责包括地址栏，书签栏，前进后退按钮等部分的工作、负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问。 Renderer Process：负责一个 tab 内关于网页呈现的所有事情 。 Plugin Process：负责控制一个网页用到的所有插件，如 flash。 GPU Process： 负责处理 GPU 相关的任务，如硬件加速、渲染合成。 下图通过任务管理器可以看到chrome开辟出了很多进程，游览器每个tab页都有可能是单独开辟的render进程。但是有时各个模块会在一个进程中。 进程分离合并时机刚刚说到各个模块有可能分离在各个进程，也有可能合并在同一个进程中，那时机是什么呢？ Chrome 限制了最大进程数量，具体的数量是根据CPU和内存的性能来决定的，如果达到了限制的进程数量，那么新开辟的模块就会合并到已有的进程中去。 比如Browser Process，如果运行在强大的硬件上，它会分割不同的服务到不同的进程上，这样 Chrome 整体的运行会更加稳定，但是如果 Chrome 运行在资源贫瘠的设备上，这些服务又会合并到同一个进程中运行，这样可以节省内存。 多进程架优点和缺点游览器多进程架构一定有它的取舍。 优点 功能模块间的相互隔离，某一渲染进程出问题不会影响其他进程。 性能高，速度快，稳定。 更为安全，在系统层面上限定了不同进程的权限 缺点 由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。 占用计算机资源。 游览器导航渲染过程用户使用游览器就是地址栏输入关键词、地址然后导航到对应页面。 Browser Process掌控Tab栏以外的各个服务，导航过程进行任务分配，主要有以下的服务。UI thread：控制浏览器上的按钮及输入框。Network thread：处理网络请求，获取数据。Storage thread：控制文件等的访问。 具体过程用户输入：首先用户会在导航栏输入数据，游览器 UI thread 分析数据结构进行不同的操作，主要要有以下两类。 查询：发送到默认搜索引擎 URL：请求URL的网站 资源获取：根据用户输入操作类型，UI thread 通知 Network thread 加载资源，首先通过 Storage thread 查询本地缓存中资源，如果有直接返回，如果没有则执行 DNS 查询，请求对应资源。 资源读取：根据返回的http头部的 Content-Type 及 MIME Type 判断响应内容相应类型，不同类型交给不同的进程处理，例如如果html文件就交给渲染进程，如果zip就交给下载进程。 页面渲染：资源加载完成之后，Network thread 会通知 UI thread，UI thread 查找 Renderer process 准备渲染页面。 确认导航：数据以及渲染进程都准备完成，Browser Process 会给 Renderer process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 Renderer process 的渲染确认消息，导航过程结束，页面呈现。 导航完成：Renderer Process 发送 IPC 消息通知 Browser process 页面已经加载完成。 以上是导航的全部流程，当然这是最初判断页面是html之后初始过程，在渲染页面过程会遇到js、css等资源请求，同样会加载对应资源，实现更新渲染视图等操作，这里需要注意的是js的执行，视图渲染都是在 Render process 中进行的，这个渲染过程是复杂的，下面将展开渲染过程。 渲染渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。 渲染过程构建DOM浏览器取回代码后，首先会构造DOM树，根据HTML标签，构造DOM树。 加载资源在构建DOM的过程中会遇到各种外部资源如css、js文件、图片、视频等。 加载图片、css资源遇到 img、link标签时会通知Netwoker thread加载该资源，不会阻塞DOM的构建 加载js资源如果遇到script标签，渲染进程则会停止构建DOM，开始加载js文件并执行，因为js文件可能会修改DOM结构，所以暂停构建。可以通过给增加 defer和async延迟执行时间。 样式计算解析的顺序是浏览器的默认样式 -&gt; 用户自定义的样式 -&gt; 页面的link标签等引进来的样式 -&gt; 内联样式。最后对所有样式进行排序获取最前面的，css权重选择就这这步。最后计算出每个节点的最终样式。 获取布局除了知道各个节点的样式之外还需要知道各个节点的位置大小，通过样式和遍历DOM获取页面各个元素的布局信息，构建出包含每个元素的坐标信息及盒子大小的 Layout tree。 绘制此时DOM树的每个节点都拥有LayoutObject对象，LayoutObject 知道如何在屏幕上绘制的内容，绘制类似像素填充的过程，遍历Layout Tree通过已知的样式、大小、位置渲染元素。绘制过程是在多个层上进行的，分别绘制每一层。 渲染层 （PaintLayer）一般来说，拥有相同的坐标空间的 LayoutObjects，属于同一个渲染层（PaintLayer）。需要保证各个渲染层的顺序才能保证，页面重叠、透明度的正常展示，因此满足形成层叠上下文条件的 LayoutObject 一定会为其创建新的渲染层。 根元素（HTML） 有明确的定位属性（relative、fixed、sticky、absolute） 透明的（opacity 小于 1） 有 CSS 滤镜（fliter） 有 CSS mask 属性 有 CSS mix-blend-mode 属性（不为 normal） 有 CSS transform 属性（不为 none） backface-visibility 属性为 hidden 有 CSS reflection 属性 有 CSS column-count 属性（不为 auto）或者 有 CSS - column-width 属性（不为 auto） 当前有对于 opacity、transform、fliter、backdrop-filter 应用动画 overflow 不为 visible 不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div 满足以上条件的 LayoutObject 会拥有独立的渲染层，而其他的 LayoutObject 则和其第一个拥有渲染层的父元素共用一个。 合成既然绘制是在多个层上进行的，那么就会有合并的过程，这里类似ps里图层的概念，不同层之间有层级的先后顺序，各个图层按照顺序合成最后展示到用户面前。 合成层（Compositing Layers）某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。 每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。满足下面条件会形成单独的合成层。 3D或透视CSS3属性 video WebGL、Canvas 混合插件 CSS3动画 绝对定位、相对定位 css设置will-change 合成层优点由于合成层拥有一个单独的GraphicsLayer，所以合成层操作不需要等待主线程的样式计算，js执行等，并且操作不会影响的其他层，总结合成层有以下的优点。 合成层的位图，会交由 GPU 合成，比 CPU 处理要快。 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层。 对于 transform 和 opacity 效果，不会触发 layout 和 paint。 根据合成层的优点我们可以作出以下的优化操作。 对动画优化合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。所以我们尽量使用使用 transform 或者 opacity 来实现动画效果。 减少重新绘制将极少重新绘制的提升为合成层，如页面的导航栏等。 虽然合成层可以提升速度但是我们 渲染流程图 事件对于游览器来说所有的手势都是事件输入，通过时间、范围来确定事件类型，事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。 游览器内核 Trident渲染引擎 –&gt; 老版本IE系列浏览器 Edge渲染引擎 -&gt; Win10中IE浏览器 Gecko渲染引擎 –&gt; Mozilla Firefox Presto渲染引擎 –&gt; Opera KHTML渲染引擎 –&gt; 早期的Safafi和Google Chrome Webkit渲染引擎 -&gt; 2001年后的Safari和Chrome以及国内的一些浏览器 Blink渲染引擎 -&gt; Webkit分支， 新版本的Chromium浏览器Google项目 游览器份额占比 参考文献：https://zhuanlan.zhihu.com/p/96986818https://juejin.im/entry/6844903569200513037http://www.starming.com/2017/10/11/deeply-analyse-webkit/https://segmentfault.com/a/1190000014520786","link":"/2020/10/22/%E6%B8%B8%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"","text":"跨域存取最近业务遇到了一个场景，一些用户信息存在B域名的localStorage中，但是这些信息需要我们在A域名的页面中获取。 方案选择当时假设了以下解决方案。 通过后端Nginx转发，通过B域名直接访问目标页面。 通过接口获取相关信息。 通过postMessage跨域获取相关信息。 方案一通过Nginx转发可以比较快解决跨域存取问题，但是由于产生其他问题： 页面地址发生改变，会影响其他有链接本页面的页面。 所有相对路径的资源都需要转发。 页面内的所有接口都需要转发，有些绝对地址请求的业务会出现跨域问题。 如果投放在微信等平台会出现安全域名的问题。 如果页面不存在上述情况和历史包袱，是一种可行的解决方案。 方案二通过后端接口获取相关信息。 接口调用增加服务器压力，如果信息获取频繁或者页面访问次数多问题会更加突出。 如果数据需要查库获取增加数据库压力。 如果是一些静态数据接口获取是一种可行方案。 方案三通过postMessage跨域通信能力获取数据 使用不好会有安全隐患。 低版本游览器会有兼容问题。 这也是我们最终选择的方案，由于业务获取的数据是用户信息方案二首先排除，方案一产生的问题比较多并且由于是旧业务很多情况不可控。 实现方案确定方案三后就是如何实现，实现过程并不复杂，主要分为以下几步。 在A域名页面a创建B域名页面b的iframe。 a页面监听message事件 b页面监听message事件 a页面通过b页面iframe返回的全局对象调用postMessage方法 b页面监听到message事件执行对应操作并获取信息 b页面通过事件对象中a页面的全局对象调用postMessage将信息返回a页面。 a页面message事件触发获取对应信息 这就是总体交互的过程，其中要注意的点就是安全，如果没有安全处理很容遭受到xss和csrf攻击，下面通过实现过程的代码来分析整个逻辑。 b页面相关代码1234567891011121314151617181920212223// 允许跨域通信的白名单，这很重要let _crossAllow = ['https://example.com.cn'];window.addEventListener('message', event =&gt; { let data = event.data; // 首选判断发送信息页面的域名是否在白名单内 if (~_crossAllow.indexOf(event.origin)) { // 以下就是获取localStorage数据过程 let keys = data.key; let sendData = {values: {}, cid: data.cid}; if (typeof keys === 'string') { sendData.values[keys] = localStorage.getItem(keys); event.source.postMessage(sendData) } else if (typeof keys === 'object') { keys.forEach((key) =&gt; { senye,aData.values[key] = localStorage.getItem(key) }) } else { return false } // 数据获取完成后返回，第二个参数是哪些域名能接收到本条信息，一定要是可信赖的域名 event.source.postMessage(sendData, _crossAllow[0]); }}); a页面相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const frameId = 'frame';const safeOrigin = ['https://example1.com.cn']; // 安全域名const frameUrl = `https://example1.com.cn`; // 跨域存取的网址const _cbs = []; // 回调函数列表let _cid = 0;// 回调函数idlet first = false; // 是否第一次创建let _frame = null;let _frameContent = null;// 监听message获取b页面返回的数据window.addEventListener('message', (event) =&gt; { // 只有可信赖网站才执行操作不然忽视 if (~safeOrigin.indexOf(event.origin)) { cbs[event.data.cid](event.data.values); }});// 操作行为，这里只写了获取行为const operators = { get: (key) =&gt; { return new Promise((resolve) =&gt; { _cbs[++_cid] = resolve; // 能获取信息的一定要是可信赖域名 _frameContent.postMessage({key, cid: _cid}, safeOrigin[0]) }) }};export default function () { // 判断是否第一次调用如果多次调用直创建一个iframe if (!_frame &amp;&amp; !_frameContent) { first = true; _frame = createFrame(frameUrl, frameId); _frameContent = _frame.contentWindow; } return new Promise((resolve) =&gt; { if (first) { // 只有当iframe load事件之后才能调用postmessage方法 _frame.onload = function () { resolve(operators); }; } else { resolve(operators); } })}// 创建iframefunction createFrame(url, id) { let frame; frame = window.document.createElement('iframe'); frame.style['display'] = 'none'; id &amp;&amp; (frame.id = id); window.document.body.appendChild(frame); frame.src = url; return frame;} 总结以上就是获取过程的全部代码，实现起来十分简单，使用postMessag跨域存取对代码和项目入侵也很小，安全问题是着重点，总结就以下注意点。 message内操作要进行域名判断 postMessage方法第二个参数目标域名一定是可信赖域名 整个通信过程都是异步的 注意好以上几点就能很好的使用postMessage进行跨域存取。","link":"/2020/11/12/%E8%B7%A8%E5%9F%9F%E5%AD%98%E5%8F%96/"},{"title":"","text":"读书笔记 - Web性能权威指南本书的目标是涵盖开发者应该掌握的所有网络知识：网络开发中用到的协议有哪些，这些协议有哪些局限性、如何针对底层网络优化自己的应用、游览器提供了那些网络相关功能，以及我们什么时候用到他们。 第一章 延迟与带宽网络通信决定性的两个因素就是延迟和带宽： 延迟：分组从消息源发送到目的地所需要的时间 带宽：逻辑或物理通信最大吞吐量 延迟延迟的组成 传播延迟：消息从发送端到接收端所需要的时间 传输延迟：把消息中所有比特转移到链路中所需要的时间 排队延迟：到来分组排队等待处理的时间 处理延迟：处理分组首部、检查错误以及确认分组目标所用的时间 光速与传播延迟光速在真空中传播速度：30万公里每秒，光纤折射率为1.5左右，接近20万公里每秒。赤道周长往返需要160ms； 最后一公里延迟中相当大的一部分往往花在最后几公里，并不是横跨大西洋产生的。由于网络接入方式五花八门，往往花费数十毫秒才能到啊ISP的主路由器。 带宽网络的主干链路几乎都是使用光纤来传输的，但是接入网络就很多常见的有光纤入户、电话链路接入、数字链路接入，不同接入方式之间速度相差很多，实际带宽还由运营商商业化的区分决定。 第二章 TCP的构成TCP负责在不可靠的传输信道上提供可靠的抽象层 措施 三次握手：SYN、SYN ACK 、ACK 四次挥手：不影响用户体验 数据完整性、顺序：分组id、校验和 流量控制：慢启动、控制拥塞窗口、控制接收窗口 丢失重发 针对TCP的优化 增大TCP初始拥塞窗口：增加初始发送数据是的数量 慢启动重启 窗口缩放：可以增大最大接受窗口 TCP快速打开，在第一个SYN中发送数据 能少发就少发 减少传输距离 重用TCP连接 第三章 UDP的构成用户数据包协议，相比于TCP他的特性就是忽略的那些特性，只提供最简单的封装服务。 特点 不保证消息交付 不保证交付顺序 不跟踪连接状态 不需要拥塞控制 NAT穿透由于ipv4地址的不足很多私有网络通过一个转发表来表述 私有ip地址：端口 &lt;-&gt; 共有网络ip地址：端口 来解决ip地址不足的问题。 对于客户端服务器架构来说，因为服务器地址一般都是共有ip，在交互期间会有必要的转换记录所并不会什么问题，但是对于c2c来说就需要解决NAT穿透问题 STUN一个公网的服务器可以通过它查询私有ip地址：端口 &lt;-&gt; 共有网络ip地址：端口的对应关系。它会发现网络中的地址转化器并进一步取得当前连接分配的外网ip地址和端口。 TURN通过一个中继服务器，两端同时链接中级服务器，然后通过中继服务器转发传数据。时间、金钱成本都很大。 ICE解决方案先通过STUN不行在使用TURN。 针对UDP的优化 应用程序必须容忍各种网络路径条件 应用程序因该控制传输速度 应用程序用应该对所有流量进行拥塞控制 应用程序应该使用与TCP相近的带宽 应用程序应该准备丢包重构发机制 应用程序应该支持校验和 应用程序因该处理丢失、重复、重排你 第四章 传输层安全TSL用来加密传输数据、认证和完整性检查来保证传输的安全。主要有以下三个服务： 加密 身份验证 完整性 TSL握手TSL采用公共密钥加密需要先握手生成共享密钥，如果使用TCP协议那么在交换数据前的准备需要：1.5 + 3 最多3个来回（TCP握手的第三次会发送密钥请求所以一般来说可以节省1次）。 证书通过证书来确定对面是否真正是我想要通信的那个对象，防止中间人攻击。 针对TLS的优化建议 减少计算成本 尽早完成握手 启用会话缓存与无状态恢复 调整合适的TLS记录大小 减少证书链长度，确保其能封装在一个tcp段内 升级TLS版本 提升TCP协议性能 第五章 无线网络概括无线网络指任何不用线缆连接的网络，有很多种无线技术，每一种技术都有自己的特点。目前主流的无线技术：Wi-Fi、蓝牙、ZigBee、NFC、WiMAX、LTE、蜂窝等。 无线网络从使用范围主要分为以下几类 个人无线局域网（蓝牙、NFC） 局域网（Wi-Fi） 城域网（WiMax） 广域网（蜂窝） 每一种无线技术的应用场景不同，有些应用需要很高的带宽，有些应用需要很低延迟，以此发展每种网络技术都有自己的技术特点服务于不同应用。 无线网络性能基础所有的无线通信方法都有一个自己的最大信道容量 计算公式：C=BW*log2(1+S/N) C：信道容量（bit/s） BW：可用带宽（HZ） S：信号 N：噪声 带宽无线通信技术的实现是靠无线波，发送端和接受端需要就使用的频率达成共识。如Wi-Fi都使用2.4～2.5Ghz的频带。 不同频率特点： 低频信号 传输距离远，覆盖范围广，但传输数据少。 高频信号 能够传输更多数据，但是距离小，范围小。 信号强度无线传输使用的是共享媒介，所以如果身边很多设备使用同样的信道频率就会出现干扰。提升信道强度的方法提高信号强度和缩短收发两端距离。 调制算法我们要把数字信号转换成模拟信号（无线电波）。调制就是数模转化的全过程。不同的调制算法效率是不一样的，具体选择取决于可用技术、收发两端计算能力，并且有些高阶的调制算法会提升调制速度但是会降低信号强度。 第六章 Wi-FiWi-Fi工作于面许可的ISM频段（不需要得到政府许可 2.4GHz），由于部署简单、设备便宜是当今最流行、应用最广泛的无线技术。 CSMA/CAWi-Fi工作于共享频段，2.4GHz有3个信道，如何避免信道冲突是通信的关键，Wi-Fi使用的是CSMA/CA冲突避免机制。 协议主要工作流程如下：1.首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。2.接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧ACK。3.发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，再发送数据。 Wi-Fi标准Wi-Fi标准是由IEEE 802标准委员会制定的。目前主流的协议是802.11b和802.11g，更高的标准协议有802.11n和802.11ac更改频率提高带宽（工作在5.0GHz）. Wi-Fi性能由于Wi-Fi工作在共享频段，无法保证只有自己使用，当附近很多人使用时就会导致对信道的瓜分，降低每个使用者的速率，并且由于没有一个规定的中央调度机制，对于任何用户的速率都是无法保证的。 QoS策略（质量服务）QoS可以保证每个客户端某种流量的最大速度，但是由于不是强制每个客户端都需要部署此策略所有对于附近用户的流量无法控制。 5GHz由于目前主流的标准协议是802.11b和802.11g都运行在2.4GHz，所以导致这个频率中的信道拥挤，可以使用最新的协议802.11n和802.11ac，他们工作在5GHz，由于没有普及所以这个频率中的信道空闲，使用起来速度会提升很多。 第七章 移动网络移动网络是我们目前上面的主要上网手段之一，每个人至少都会有一部移动网络设备，其特点就是可移动设备，与传统pc电脑，对功耗，网络的要求也是不一样的。 G字号网络目前五代移动网络有1G、2G、3G、4G、5G（这本书写的时候还没有5G技术，书中没有相关介绍）。这其中有一段技术的发展历史可以书中查看，最后有两个组织来具体制定通信标准： 3GPP，负责制定UMTS（3G于GSM技术结合的产物），后来LTE（主要的4G技术）也是这个项目组制定的。 2GPP2，负责基于CMDA2000制定3G技术规范。 4G所谓4G就是一组具体的数据要求： 以IP分组交换网络为基础 与之前的无线标准兼容 移动客户端速率大袋100Mbit/s 100ms控制面延迟，10ms用户面延迟 资源可在用户间动态分配 可变带宽分配，5～20Mhz 实际还有更多的要求，所以4G包括现在的5G并不是一个单独的技术，而是通过各种技术达到具体的一些数据要求的技术集合。 设备移动网络不得不提使用主体就是移动设备，移动设备的种类繁多，不同设备由不同的硬件组成，其中有一项是无线基础设施，它决定移动设备能使用哪些网络标准，比如iphonex不支持5G就是因为无线基础设施的不支持。 无线电资源控制器（RRC）无线电资源控制器负责调度协调设备与无线电基站之间所有的通信连接。 使用物理连接时计算机连入网络并始终在线，通信两端可以随时发送数据，Wi-Fi的连入方式也是类似的的，这样会导致两个问题： 共享信道一直连入，导致冲突的可能性很大。 因为可以随时和发送接收信号，需要无线电接收发始终开启，从而导致很大的耗电量。 这两点对于WAN和移动设备问题都是比较明显的，而解决方式就是通过RRC。 RRC控制移动设备的无线电接收发什么时候开启，带宽多大，功率多少，监听设备的电源状态，一般每个信号塔总都装有RRC。 LTE RRCRRC在不同标准中实现方式是不一样的，我们这里通过目前4G的主流标准LTE看看他的实现方式。 一般设备只有两种状态： RRC空闲设备的无线电模块处于低功耗状态，只监听网络的控制信号。 RRC连接设备的无线电模块处于高功耗状态，要么传输数据，要么接受数据。 处于空闲状态时用户不能发送和接受数据，如果想要收发数据数据需要向RRC发送一个切换请求，这个过程会有几次往返，其中会有些配置参数包括带宽多大、功率多少等，切换后就与信号塔的连接准备就绪RRC变成连接模式。而且连接后不会切换成空闲模式。 RRC连接模式需要的功耗很高，但是连接后不会切换回空闲模式，为了节省功耗，连接模式也有很多子状态。 连续接受网络环境准备就绪、以分配网络资源 短不连续接受（短DRX）网络环境准备就绪、无分配网络资源 长不连续接受（长DRX）网络环境准备就绪、无分配网络资源 连续接受设备可以接受和发送数据。如果设备空闲会被切换成短DRX，网络环境准备就绪但是无法接受和发送资源，只会周期性的监听广播，如果长时间处于空闲则会切换成长DRX。当要发送数据和接收到广播的接受数据信号时会快速切换成连续接受模式。 运营商架构运营网络中的基础设施和架构取决于部署网络属于那一代和什么类型，下面记录了LTE的架构。 RAN（无线接入网络）负责把用户请求转发到分配好的无线信道，从用户设备接受或者想用户设备发送数据，也就是基站。 EPC（核心网络）负责数据路由（发送给谁，接收给谁）、账户（匹配）和策略管理（速率、位置等）。也就是把无线网络和公共互联网连接到一起，EPC中有几个核心的模块。 PGW负责连接运营商网络和公共网络，维护和分配ip地址、分组过滤和检测、QOS分配、DoS保护。 PCRF负责维护和评估针对分组网关的规则。 SWG负责和某个信号塔连接，然后收发数据，这里某个信号塔是通过MME查询的。 MME接收到SWG发送的查询请求后，会查找用户的位置，返回用户附近信号塔的id给SWG来与其建立连接。 分组流数据由流入和流出，对应LET运营商架构分别有出站流和入站流。 出站流1.请求建立RRC连接2.返回控制信息连接网络连接（这个过程会有几次）3.把数据传输到无线信号塔，在转发给网络核心，从SGW发送给PGW4.发送到公共网络 入站流1.公共网络传输到PGW2.发送给SGW，SGW通过MME查询用户信号塔位置。3.通过信号塔广播信号，指定设备接收到信号，建立连接。4.返回建立连接信息5.返回具体信号塔和设备相关信息6.SGW发送数据给指定信号塔。7.信号塔用刚刚连接的连接传输数据。 第八章 移动网络优化针对移动网络和移动设备特点有其独特的优化。 节约用电 减少无线电接口使用 减少无线电唤醒次数。 消除周期性及无效的数据传输 轮询在移动网络中代价很高。轮询会使无线电模块无法进入休眠模式或者在连续模式和休眠模式中一直转换。 使用推送和通知。 出站和入站请求应该合并和汇总。集中处理数据请求和接受，减少休眠模式的切换。 非关键性数据推出到无线电模块活动时进行。没有必要为了非关键性数据激活休眠模式。 爆发性传输数据并转为空闲尽可能多的集中下载和上传数据，然后转为空闲模式 第九章 HTTP简史HTTP是互联网上采用最普遍的一种协议。 HTTP 0.9Tim Berners-Lee构建了一个简单HTTP的原型。 客户端请求是一个ASCII字符串 客户端请求由一个回车符结尾 服务器响应是一个ASCII字节流 服务器响应是一种超文本编辑语言 连接在文档传输完毕后离开 HTTP 0.9是HTTP的第一个版本，1991年发布，该版本只有一个get命令，返回没有首部等信息。 HTTP 0.9实现的功能： 客户端/服务器、请求/响应协议 ASCII协议，运行在TCP/IP之上 传输HTML 每次请求后会关闭 HTTP 1.0由于人们对新兴Web的需求越来越高，HTTP0.9很多根本性不足的问题暴露出来，1996年，HTTP工作组发布了RFC 1945，解释说明了很多1.0的公共方法，不过它并不是一个正式的互联网规范。 HTTP 1.0新增的功能： 请求可以有多行首部字段构成 响应对象前面添加了一个响应状态 响应对象由换行符分隔首部字段 响应对象不局限于HTML HTTP 1.11997年由IETF发布HTTP1.0的标准RFC 2068，1996年RFC 2616在标准中增加了改进。HTTP1.1也是我们目前使用最多的HTTP版本，其中需要掌握知识点和新增的功能点很多，通过图解HTTP一书可以学习其中大致的内容。 HTTP 2随着把越来越多的应用部署到Web上，对HTTP的要求也越来越高，HTTP工作组2012开始开发HTTP2,在2015年发布，主要目的是改进传输性能，降低延迟和高吞吐量，并且现有的网站和协议无需修改都可以在HTTP2中跑起来。 第10章 Web性能要点前面分别介绍了通信中各个模块的性能优化，然而一次完整的通信涉及到各个模块，现在转移到更宏观的Web心性能优化。 交付形式目前网页交互的形式主要有以下三种： 超文本文档 富媒体网页 Web应用 页面的交互形式越来越多样，尤其Web应用的多样和复杂，测量的标准也不仅仅局限于资源加载速度要需要考虑以下问题： 应用加载过程的里程碑是什么？ 用户第一次交互的时机何在？ 什么交互应该吸引用户参与？ 每个用户的参与及转化率如何？ 剖析现代Web应用一个网页现在所请求的资源数量的多样的，多个请求主机和多种资源类型。而网页与客户端安装本地资源不同，每次访问都等于是一次重新的安装，所以网页的性能提升一直是被研究的话题。 速度、性能与用户期望每种应用都有自己特定的需求，这取决于应用场景、用户期望、以及复杂度，但是及时的响应是一个统一的目标。 时间 感觉 0～100ms 很快 100～300ms 有一点点慢 300～1000ms 机器在工作 &gt;1000ms 干点别的吧 可以看到在几百毫秒以内响应客户是十分重要的，但是DNS、TCP、TSL等查询和握手的时间就浪费了几百毫秒。 分析瀑布图瀑布图显示了页面加载资源的顺序和每个资源各个阶段的时间，分析瀑布图是性能优化的重要手段。 性能来源：计算、渲染和网络访问Web执行主要有3个任务：获取资源、页面布局和渲染、JavaScript的执行。 页面性能瓶颈是延迟而不是带宽，性能优化要着重于降低延迟。 性能度量通过游览器 Timing API 获取用户真实数据。 针对游览器的优化建议从核心的优化策略可以广泛的分为两类： 基于文档的优化CSS、js解析管道、优先级安排、资源加载顺序、优先获取主要资源等。 推测性优化预测用户下一次操作，资源预加载、DNS预解析、预渲染等。2完全111 第11章 http1.x上面介绍了http的发展史,每个版本的升级都是优化上个版本的性能瓶颈，这一章主要讲述了针对http1.1优化了哪些问题、还存在哪些问题、如果优化这些问题。 http1.1引入了很多重要特性，以下是比较熟悉的 持久化连接 http管道 分块传输 更好的缓存机制 持久化连接的优点http是基于tcp的，tcp是面向连接的每次都需要3次握手，假设页面有同一个服务器的两个资源，则需要握手两次，如果在第一次tcp连接后服用则减少了一次握手，这就是持久化连接的优点。在请求同一个服务器资源越多、延迟越高则持就换连接的小则越明显。总结有以下优势 减少握手次数，降低延迟 减少tcp慢启用的影响 减少服务器tcp连接数量 http管道持久化连接复用存在的连接完成多次请求，但是必须发出一个请求并完成响应以后才能继续发送下一个请求，http管道则是在第一个请求之后马上进行第二次的请求发送合并成一个请求，然后在服务器的同一个响应中返回所有资源。管道优势 两个资源的请求合并成一次往返 http1.1问题 队首阻塞 http1.1无法多路复用，需要等待两个请求全部完成后才能响应 使用多个tcp连接由于http1.0并不支持多路复用，通过持久化连接只能当一个请求完成时复用连接在发送下一个，然而这样太慢了，所以游览器一般会使用多个tcp连接来并行的加载资源，chrome游览器一般是允许统一域名下最多6个tcp连接。 域名分区由于上述的对同一域名下tcp连接数量限制，所以通常对资源请求数量很多的网站会将资源分散在多个不同的域名下。但是这样虽然突破了tcp数量的的限制，却增加了资源发布复杂性，多一次的dns解析。 连接拼合连接：把多个资源类似css、js合并成一个请求资源中。优点： 减少了http请求数量缺点： 其中有一个修改则需要重新加载全部资源 js和css需要全部读取后才能执行，拖延了首次实行的时间 拼合：把多张图片拼合成一个更大的图片优点： 减少了http请求数量缺点： 其中有一个修改则需要重新加载全部资源 增大了对内存的消耗，只显示部分但内存中读取了所有 嵌入资源将资源内嵌文档中，从而减少请求次数。 将js、css内嵌到script、style标签中 将图片转化为base64，会增加资源的体积约30%，适合小资源 第12章 http2.0http2可以使连接更快、更简单、更健壮。上面介绍了很多基于http1.0性能优化的方法，但是这些优化都是本身基于协议问题的优化方法，最后的解决方式还是对协议本身进行优化，http2就解决了上述的大部分问题。 http2宣言： 相比于http1.0，用户大多数情况下对延迟的感知要有实质上的、可度量的改进。 解决队首阻塞 多路复用 对http1.1语法语义没有入侵 可扩展机制 二进制分帧层它定义了如何封装http消息并在客户端与服务器之间传输，类似于tls，将原来以文本的方式分隔成了更小的消息和帧，并对他们采用二进制编码。 二进制分帧格式每个帧有32位的首部信息 16位表示长度 8位类型，表示如何解释帧其余部分的内容 8位标志 根据类型不同可以知道如何解释剩下的内容如DATA：本帧用于传输http消息体，HEADERS: 传输流的首部也代表着一个新流的建立。 流、消息、帧 流已建立的连接上的双向字节流 消息与逻辑消息对用的完整的一系列数据帧 帧http2通信的最小单位 多向请求与响应在http1.1中想要并行的响应多个请求，只能建立多个tcp连接，而http2通过二进制分帧层则可以在同一个tcp中发送多个资源请求，客户端和服务器可以将多个请求分解成互不影响的帧然后乱序发送，在送达后根据流的ID进行组装，所在发送请求帧的同时也在返回响应帧，实现了请求响应的同时执行。 请求优先级既然可以在同一个tcp中发送很多独立的帧，那么就可以按照某种规则优化发送帧的顺序，也就是优先级。每一个流都可以设置一个31比特的优先值：0最高 2^31-1最低。服务器和客户端则可以根据这个值以最优的方式发送流、消息和帧。 每个来源一个连接http2.0所有同一个域名的来源请求都在同一个tcp连接下传输。 服务器推送http1.1只能一个请求一个响应，http2则实现了一个请求多个响应，服务器可以根据客户端请求内容推测客户端接下来会请求哪些资源然后逐一返回，这样就减少了客户端发送请求的时间。 首部压缩http每次通信的都会携带一些首部信息，用于描述资源和客户端信息，但是这些首部中有很大一部分是重复的例如ua，cookies等，所以http2在服务器客户端各生成了一张首部表，如果本次请求的首部和表的的重复则不发送不然则替换，这样实现了head的压缩。 第13章 优化应用交付经典的优化最佳实践 减少DNS查找 重用TCP连接 减少HTTP重定向 使用CDN 去掉不必要资源 客户端缓存通过首部字段控制客户端缓存 压缩传输内容开启Gzip、图片格式选择 消除不必要的请求开销控制cookies大小 并行处理请求和响应多个tcp连接并行、ttp2、管道技术 优化协议 第14章 游览器网络概述游览器是web开发中最重要的平台，他其中包括了太多的组件比如进程管理、安全沙箱、js引擎、图形渲染、存储系统、网络机制等。游览器的网络组件外部看可以理解成一个简答的获取机制，内部看却十分复杂有自己的优化、api和服务。 连接管理与优化运行在游览器的web不会负责网络套接字的生命周期，在游览中会有一个套接字池，同源的请求会放在同一个套接字池中，主流游览器的数量一般都是6个，如果超出这个就需要等待之前的请求响应完成去复用tcp连接。然而具体的连接、复用、断开都不需要web应用开发者去关心，这些全是游览器来做的。 游览器会对套接字池管理进行优化 按照优先级发送排队请求 重用套接字 预测提前打开套接字 合适的时间关闭 优化带宽的分配 网络安全和沙箱 连接限制 请求格式化与响应处理 同源策略 资源与客户端状态缓存 缓存资源 cookies保存客户端状态 应用API与协议 抛出XHR、websocket、WebRTC等API给应用使用。 第15章 XHRXHR是游览器抛出来API，让开发人员通过JS传输数据，是AJAX的核心技术。通过使用这个API很多复杂的网络操作游览器都帮我们实现了，我是只需要专注于业务实现。 XHR本身有一些功能上写限制：－服务器主动推送－没有流式数据传输的API 具体XHR API的使用可以看另一篇专门的博客 第16章 Server-Sent Events让服务器可以向客户端流式发送文本消息，比如服务器的事实更新和通知。实际上，SSE提供的是一个高效XHR流实现，本质上消息交付是实现了一个HTTP长连接，但是游览器帮我们管理链接、解析消息我们只需要简单的调用API即可，专注于业务。 具体SSE API的使用可以看另一篇专门的博客（未完成） 第17章 WebSocketWebSocket可以实现客户端与服务器端的双向、基于消息的文本或二进制数据传输，他是游览器中最接近套接字的API。他是游览器中最灵活的一个传输机制，可以让客户端与服务器之间实现基于数据流各种数据格式的传输，并且任何一方可以随时发送数据。 具体SSE API的使用可以看另一篇专门的博客（未完成） 第18章 WebRTCWebRTC由一组标准、协议和Javascript APIZ组成，实现游览器之间（端到端）的视频、音频以及数据的共享。 大多数游览器抽象成了3个API MediaStream：获取音频和视频流 RTCPeerConnection：音频和视频数据通信 RTCDataChannel: 任意数据之间的通信 具体WebRTC API的使用和详情信息可以看另一篇专门的博客（未完成）","link":"/2020/12/29/Web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"},{"title":"","text":"深入HTTP和性能优化HTTP协议是互联网上采用最普遍的协议，也是我们前端开发过程中遇到最多的网络协议，几乎所有的资源请求、数据获取、用户交互都是使用HTTP，所以深入理解HTTP对于性能优化是极为重要。 主要从下面四个角度来深入HTTP 目前主流HTTP发展历程和各个版本 HTTP相关协议如TCP、UDP、TLS 目前主要版本存在问题和优化方法 未来的HTTP 发展历程HTTP从1991年定稿到目前已经经历了4个主要版本迭代，从最初的只有一个简单的get请求到现在已经十分复杂，推动它一直更新迭代的动力是web应用发展越来越复杂，对web应用的性能的要求也越来越高。 HTTP/0.9HTTP 0.9是HTTP的第一个版本，1991年发布，该版本只有一个get命令，没有首部等信息。 HTTP 0.9实现的主要功能： 客户端/服务器 -&gt; 请求/响应协议 运行在TCP/IP之上 传输HTML 每次请求后会关闭TCP连接 HTTP/1.0由于人们对新兴Web的需求越来越高，HTTP0.9很多根本性不足的问题暴露出来，HTTP1.0也就随即而生，他与我们目前的HTTP报文相比看上去已经差别不大。 HTTP1.0新增的主要功能： 增加了很多请求方法如：POST、PUT 请求可以有多行首部字段构成 响应对象前面添加了一个响应状态 响应对象由换行符分隔首部字段 响应对象不局限于HTML HTTP/1.1HTTP1.1是在HTTP1.0的基础上增加了一些功能来优化网络连接。 HTTP1.1新增的主要功能： 持久化TCP连接 HTTP管道 分块传输编码 更好的缓存机制 当然HTTP/1.1新增的特性很多，这只是其中几个主要的功能 HTTP/2HTTP/2将HTTP/1.1存在的问题集中在协议内部解决，在不改动HTTP1.1语法语义的基础上将解决方案内置在传出层中进行优化应用、改进性能。 HTTP2新增的主要功能： 多路复用 多请求与响应 首部压缩 服务器推送 请求优先级 2018年初，最热的前一千个网站中约40%运行着HTTP/2，而在Firefox发出的HTTPS请求中，约70%的请求得到了HTTP/2响应。主流的浏览器、服务器以及代理都支持了HTTP/2 HTTP相关一个HTTP网络请求并不知有HTTP协议的参与，它只是在应用层协议中的协议，HTTP性能上暴露出来的问题和解决方案有些并不在HTTP协议本身中，需要我们去知道在整个网络传输过程中其他的协议内容，从整体的角度来考虑性能的优化和提升。 HTTP协议建立在TCP/IP协议上，通过TLS实现加密传输：IP / TCP / TLS / HTTP TCP传输控制协议是为了在不可靠的通信连接上，提供逻辑上的可靠信道服务的协议。HTTP是基于TCP的应用层协议，所以TCP实现的功能和出现的问题HTTP也都有。 TCP实现的功能： 面向连接、全双工 保证数据完整性、顺序 流量控制 丢失重发 TCP会做一些方案来保证上面功能的实现，不可避免的会造成一些性能问题，如三次握手、慢启动等，但是后续可以通过对HTTP协议的改造和TCP的优化来减少这些影响。 TLSTLS是一个安全协议，通过HTTP+TLS就能形成HTTPS，通过加密可以保证我们传输过程中数据的隐私性、安全性、不可篡改从而保证我们的传输安全，但是这个是有性能代价的。目前主流（2020年）使用的是TLS1.2版本，使用公共密钥加密方法来进行密钥交换和加密。 SSL协议起源于1994年，当时网景公司推出首版网页浏览器及HTTPS协议，用于加密的就是SSL。此后相继推出SSL2.0及3.0版本，1999年IETF将SSL标准化，即 RFC 2246 ，并将其命名为TLS。2006年和2008年又分别推出TLS1.1和TLS1.2版本。 这里看到密钥的交换需要4次握手，从开始请求链接到最后真正传输数据有3RTT时间的准备，如果客户端和服务器相隔较远等可能会有几百ms的延迟这对用户体验的影响是很大的。 UDP是用户数据报协议，与TCP一样是传输层协议，他与TCP区别就是只实现了传输层最基础的功能，几乎没有做什么特别的事情。这样的特点就会使起特别的轻量，这对于提升网络传输速度是诱人的，所以HTTP/3就搭建在了UDP协议之上，可靠的传输机制、流量控制等在应用层实现，实现了不修改当前网络基础设施的情况下提交网络性能。 HTTP的性能问题和优化往往ToC页面对性能要求的更高，响应时间能决定用户的去留和公司最后的利益。 不同响应时间客户的感觉：| 时间 | 感觉 || — | — || 0～100ms | 很快 || 100～300ms | 有一点点慢 || 300～1000ms | 机器在工作 || &gt;1000ms | 干点别的吧 | 所以尤其是ToC页面对性能要求和最后盈利的关系是密切的，下面就从各个HTTP版本的角度来看各个版本的性能问题以及下个版本的优化方式。 大部分web应用的是性能瓶颈是延迟，不是带宽。 HTTP/1.1的性能HTTP/1.1是目前主流使用的HTTP协议版本，已经使用了很长的时间，很多公司目前都是HTTP/1.1和HTTP/2.0共存，所以知道它的特点、缺点、解决方案还是很重要的。HTTP/1.1新增的功能非常多这里列举了几个主要和常用的点。 持久化链接HTTP/1.1是建立在TCP协议之上的，TCP协议是面向连接的服务，需要通过三次握手建立连接并且建立连接初期会有慢启动，所以建立一个新的TCP链接成本是比较大的。 既然建立比较大那么我们复用之前链接就可以提升性能了，这就是持久化链接。 但是HTTP同一个TCP链接请求过程是：发送请求-&gt;接受响应 -&gt; 下一个HTTP请求。过程是串行的，这是HTTP设计机制，如果页面有很多请求那么这个过程是漫长的显然不可能这样。那么这个问题的解决方案就是同时开启多个TCP连接就可以并发请求资源，那么并发多少呢？在考虑用户性能和服务器压力后通常是6个，如果请求资源大于6那么就需要排队等待，所以HTTP/1.1就出现了队首阻塞问题。 多域名刚刚说到结合了用户体验和服务器压力单个域名设置的最大TCP链接并发数是6个，那么如果页面请求资源过多排队6个TCP链接对性能损害是大的。所以可以通过把静态资源分布在多个域名下就可以突破6个链接的限制从而实现多链接并发。 拼合除了把资源部分在不同域名下，我们还可以将资源拼合成一个HTTP链接来实现资源请求数的减少，变相解决队首阻塞问题。通常会将多个js文件合并成一个，多个图片合成一个（雪碧图）。 123https://s.thsi.cn/js/m/common/bridge.js + https://s.thsi.cn/js/m/common/zepto.jshttps://s.thsi.cn/cb?js/m/common/;bridge.js;zepto.js 但是这样也会存在一些问题比如拼合js中有一个改动就会缓存失效请求加载全部文件，图片合并只现实其中一小部分但需要把整张图片加载到内存中去。这就要根据具体的情况、资源等进行取舍。 管道化（多路复用）刚刚说到了HTTP通过TCP的请求过程：发送请求-&gt;接受响应 -&gt; 下一个HTTP请求。那么这时候就可以想到那么我一次发送多个请求那么不是就可以复用TCP链路并且解决队首阻塞问题。这就是管道化：允许同时请求请求 -&gt; 多个响应，但是由于HTTP在服务器的机制需要处理完上一个请求后才能响应下一个，还是出现了队首阻塞问题只不过是把阻塞时间由客户端放到了服务器端，并且还加大了服务器的压力，所以HTTP/1.1的管道化并没有怎么推广和使用。 缓存机制缓存是加速响应的重要措施，如何提高缓存命中率、及时更新、灵活控制都是协议重点考虑的内容，HTTP/1.0通过Expires字段（一个绝对时间字符串）控制缓存，但是存在客户端时间不准确，时区等问题影响缓存效果，HTTP/1.1增加了Cache-Control、If-Modified-SinceLast-Modified、If-None-Match\\ETag更灵活、准确的控制缓存。 压缩可以通过压缩传输的内容来减少传输大小，提升传输效率。通过 Accept-Encoding 协商压缩格式。 HTTP/2的性能我们看到HTTP/1.1还是存在很多的性能问题，有些可以通过一些方案来解决，但这并不能除去协议本身的问题，而且有些解决方案都是有所牺牲的，所以HTTP/2出现了。 HTTP2的目的是通过支持请求和响应的多路复用来实现减少延迟，通过压缩头部降低额外开销，同时实现请求优先级和服务器推送的功能。 HTTP/2: the Future of the Internet 这是一个官方演示，可以明显的看出HTTP/2相比于HTTP/1.1的性能提升。 多路复用HTTP/2的优化主要都是建立在多路复用的基础上，所有同一个域名的来源请求都在同一个TCP连接下传输，通过了二进制分帧、请求优先级等来实现多路复用。 二进制分帧层它定义了如何封装http消息并在客户端与服务器之间传输，类似于TLS，将原来以文本的方式分隔成了更小的消息和帧，并对他们采用二进制编码。 要理解HTTP/2的多路复用需要知道以下几个概念： 流已建立的连接上的双向字节流 消息与逻辑消息对用的完整的一系列数据帧 帧http2通信的最小单位 帧格式每个帧有32位的首部信息： 16位表示长度 8位类型，表示如何解释帧其余部分的内容 8位标志 根据类型不同可以知道如何解释剩下的内容如DATA：本帧用于传输http消息体，HEADERS: 传输流的首部也代表着一个新流的建立。 请求优先级既然可以在同一个流中发送很多独立的帧，那么就需要按照某种规则优化发送帧的顺序，也就是优先级。每一个流都可以设置一个31比特的优先值：0最高 2^31-1最低。服务器和客户端则可以根据这个值以最优的方式发送消息和帧。 多向请求与响应在HTTP/1.1中想要并行的响应多个请求，只能建立多个TCP连接，而HTTP2通过二进制分帧层则可以在同一个TCP中发送多个资源请求，客户端和服务器可以将多个请求分解成互不影响的帧然后乱序发送，在送达后根据流的ID进行组装，所在发送请求帧的同时也在返回响应帧，实现了请求响应的同时执行。 头部压缩HTTP每次通信的都会携带一些首部信息，用于描述资源和客户端信息，但是这些首部中有很大一部分是重复的例如ua，cookies等，所以HTTP/2在服务器客户端各生成了一张首部表，如果本次请求的首部和表的的重复则不发送不然则替换，这样减少了头部字段的无效压缩。 服务器推送HTTP/1.1只能一个请求一个响应，HTTP/2则实现了一个请求多个响应，服务器可以根据客户端请求内容推测客户端接下来会请求哪些资源然后逐一返回，这样就减少了客户端发送请求的时间。 队头阻塞我们刚刚看到HTTP/1.1很多性能问题是由于协议本身机制所引起的队头阻塞问题，那么HTTP/2解决了么？并没有完全解决，由于TCP传输是使用滑动窗口，如果某个TCP段丢失了那么需要等待，所以还是出现了对头阻塞问题，但问题已经不在HTTP协议上了。所以下一个版本替换的目标就在应用层协议上了。 HTTP/3HTTP/2已经解决了HTTP/1.1协议本身的很多问题，但还是基于TCP协议，TCP本身的一些特性牺牲了性能，并且由于TCP在目前的网络环境中已经十分普及无法修改所以HTTP/2的性能瓶颈到了TCP身上。并且前面说到为保证传输安全会有TLS层，HTTP/2主要使用的是TLS1.2版本，交换密钥和加密的过程也会造成性能损耗。 HTTP/3就主要着手于TCP协议和TLS进行了优化： TCP -&gt; UDP 在UDP和HTTP协议之间新增QUIC协议 TLS1.2 -&gt; TLS1.3 建立链接我们看到通过TCP转化为UDP+QUIC，TLS1.2转化为TLS1.3可以节省2RTT，恢复链接可以实现0RTT直接发送数据。 QUICQUIC是谷歌提出的一种应用层传输协议,建立在UDP之上，摆脱了TCP得一些性能问题，通过自己实现有序、可靠、安全、灵活、快速的传输服务器。 目前，在Chrome中有85%以上关于谷歌自有业务的请求响应都是通过QUIC承载，可以说QUIC已经经受住了真实复杂外网环境的考验。 建立连接QUIC建立连接只需要1-RTT和0-RTT，其中初始主要用在信道建立和密钥交换。 TLS1.3 TLS1.3协议针对安全强化及效率提升等方面进行了大量修改，IETF相继推出个28个草案版本，历时4年多，在2019年8月份完成最终的标准化 (RFC 8446) 。 TLS1.3版本更简练，建立TLS连接不再需要 2RTT，而只需要1 RTT，是因为浏览器第一次就把自己的密钥交换的素材发给服务器，这样就节省了第三次消息，少了0.5个RTT时间。 TLS1.3用了经典的秘钥加密算法（DH算法）来实现对称秘钥的交换，其中Alice的a和Bob的b是本地生成的不参与传输，这样就不会让第三方劫持，只要其中g和p选择的足够大和安全就不存在被劫持的风险。 0-RTT先前已连接过一个服务器的客户端可能缓存来自该连接的某些参数，并在之后与该服务器建立一个无需等待握手完成就可以立即传输信息的0-RTT连接，从而减少建立新连接所必需的时间。 数据传输链接建立的根本是为了传输数据，一个QUIC链接连接后其中会有很多的流，每个流是独立的，是一个单独的请求。 避免队首阻塞HTTP/2解决了应用层的队首阻塞问题，但是由于还是建立在TCP链接之上，如果TCP丢了一个包就需要等待，还是会出现队首阻塞问题。HTTP/3抛弃TCP，通过QUIC协议控制。 客户端和服务器还是会建立一个链接，但是链接里有多个流，流的关系是并列的，如果其中一个流丢失了数据并不能影响其他流的传输。 交付顺序TCP是按序交付的，QUIC同样也实现了，但是也有区别，上面说到了同一个QUIC链接中会有很多个流，QUIC保证每个流内部是按序交付的，但是不通流之间是乱序的。 可靠性由于UDP是不可靠的协议，所以QUIC在其上层提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。 拥塞控制QUIC的拥塞控制原理和TCP的类似如慢启动、拥塞避免等，但是做出了一定的优化处理。 挑战计算机网络中间有无数个路由器、交换机、NAT等网络设备，这些设备建立初期就已经存在了TCP、UDP等协议，所以对这些协议的特点、特性都有所支持。但新加的协议怎么办？不可能更新计算机网络的所有设备，所以明知道TCP有一些性能问题，但是没有人说重新修改TCP协议，这样的代价太大了。 HTTP/3是建立在UDP协议之上，UDP是无连接的，所以中间各种网络设备都不会记录UDP链接状态，但是QUIC是面向链接的，这样如何让中间NAT知道当前UDP的连接状态？何时断开连接？这是它未来的挑战。 参考链接QUIC的五大特性及外网表现HTTP/3 explainedWeb性能权威指南","link":"/2021/01/06/%E6%B7%B1%E5%85%A5HTTP%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"ES7","slug":"ES7","link":"/tags/ES7/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"源码解析","slug":"源码解析","link":"/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"游览器","slug":"游览器","link":"/tags/%E6%B8%B8%E8%A7%88%E5%99%A8/"},{"name":"业务实战","slug":"业务实战","link":"/tags/%E4%B8%9A%E5%8A%A1%E5%AE%9E%E6%88%98/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"进阶","slug":"进阶","link":"/categories/%E8%BF%9B%E9%98%B6/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}