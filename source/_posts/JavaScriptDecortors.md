# 深入JavaScript类型转换
总所周知javascript是一门弱类型语言，这为我们提供了灵活行、简易性，但有时也给我们出乎意料结果，其中最多的就是类型转换。
类型转换我们通常意义上分为两种，显式类型转换和隐式类型转换。这两种并没有明确的区分，通常取
决于转换的隐蔽性。如果我们不理解类型转化的发生，那么会出bug，隐式类型转换也是我们经常诟病的，但是如果我们理解了所有的转换情况那么在我们眼里任何转换就都是显式转换，那么所有转化都是我们可以预料到的.
<!--more-->
## 抽象操作
要去理解类型转换首先要知道各个类型的转化的基础规则，在ES5中定义了一些抽象操作（仅供内部使用的操作）
### ToString
非字符串类型至字符串类型的转换
基础类型:
- null -> "null"
- undefined -> 'undefined'
- true -> 'true'
- 100 -> '100'

引用类型:
- 普通对象会返回内部书香[[class]]（内部的分类）的值 {} -> [object Object]
- 数组默认每一项用“，”拼接 【1，2，3】-> “1，2，3”

### ToNumber
非数字类型至数字类型的转化
基础类型:
- true -> 1
- false -> 0
- null -> 0
- undefined -> NaN
- string “123” -> 123  "123a" -> NaN

引用类型:
- 首先会被转化为基础类型，然后根据基础类型的转化规则转化

### ToBoolean
非布尔类型至布尔类型的转换

##### 假值
- undefined
- null
- false
- 0 +0 -0 NaN
- “”

##### 真值
- 假值以外的值都是真值

### ToPrimitive
对象到基础类型的转化
1. 首先调用对象valueOf方法
2. 判断valueOf方法的返回值是不是基础类型，如果是则转化完成
3. 如果valueOf方法返回值不是基础类型则调用toString方法

## 类型之间转化
类型转化通常是：
- Object -> 基础类型
- 基础类型 -> 基础类型

#### 其他 -> Number
- +false
- ~ ~{}
- Number()

##### ~运算符
字位操作非运算符我们平时需要使用的场景并不多，但是在一些场景下非常好用。
首先字位运算符之适用于32位整数，所以要先将操作数转化为32位整数，然后取反也就是返回操作数的补码。
公式：~X = -（X+1）

###### 类型转化
~false = ~0 = -（0-1） = -1

###### 判断
除了类型转化之外，～在判断中也十分有用，我们知道0是所有数字中唯一的假值，此时应该联想到indexOf方法，我们知道indexOf返回查询字符串的位置索引，如果没有查询到则返回-1
``` javascript
    if('china'.indexOf('x') > -1 ){....}
    // 可以转化成
    if(~'china'.indexOf('x')){...}
```

###### 字位解除
刚刚说过字位操作符会将操作数先转化成32位整数，所以我们可以使用它作为小数位的截取,先取反两次。
```javascript
~~34.33 // 34
~~-34.33 // 34
```
可以看出这里是直接截取小数位的。

#### 其他 -> String
转化成字符串相对比较简单
- false.toString()
- String(false)
- false + ''

#### 其他 -> Boolean
- !1
- Boolean()
- if(...) 
- for(...;...;...)
- ？：
- while(...) do...while(...)
- || && 左边的表达式

### Number <-> String
数字和字符串之间的转化应该我们平时最常见的转化，所以单独提出来总结一下。

#### Number -> String
数字转化成字符串的：
- String(1) 根据抽象操作的ToString规则 
- 1..toString()
- new Date(1571239714845)
- 1 + ''  

#### String -> Number
- Number() 根据抽象操作的ToNumber规则
- parseInt()、parseFloat()
- ~'123'
- +or-'123'
- new Date('2019/10/16')

##### 解析速度
parseInt > parseFloat > Number
- parseInt和parseFloat是只处理字符串，任何不是字符串的值都会先转成字符串包括数字，然后在根据规则解析字符串最后返回数字，流程相对简单，并做了目的性强的优化，所以处理速度快。
- Number构造函数会首先判断类型然后根据不同类型在做相应的转化，这里耗费的比较多时间，但是这些时间的耗费都是微妙级的。

### Object -> *
对像转化成基础类根据ToPrimitive规则。
toPrimitive操作会获取对象的[[Default]]。通常就是先调用valueOf()方法判断返回的时候是基础类型，是则返回，不是则调用toString()方法
``` javascript
let a = {
    valueOf(){
      return 1 
    }
}
a + '' // '1'
```
在上述运算中首先需要对象a转化为基础类型，返回了1，在 1 + ‘’，返回了 ’1‘。

## 宽松相等和严格相等
宽松相等与严格相等的区别是严格相等比较过程中不允许类型转换，宽松相等做的事情其实比严格相等更多，但是相差的时间都是几微秒。

在平时开发过程中推荐使用严格相等，使用宽松相等场景并不是很多。我平时写业务代码与后端数据交互时，返回“数字”的类型是不明确的
这时我更多时使用Number类型转化一下，这样在未来阅读代码时候类型就很明确了。

虽然使用场景不多但是知道他的转换规则还是有必要，万一别人用呢。

### 宽松相等
两种类型不同值比较时会将两边转化成同类型在进行比较，这里我们最主要的就是弄清楚各个类型比较时转化的规则

#### 非常规情况
- NaN == NaN false  不与任何值相等包括自己
- -0 == +0 true
- null == undefined true 

#### Number和String之前比较
- 使用ToNumber规则将字符串转化为数字
- 数字之间比较

#### 其中一方有Boolean
- 首先将Boolean转化为数字 false->0 true->1
- 在比较两边类型是否相等，不同类型在进行转化比较

#### 对象和非对象之间的比较
- 首相将对象转化为基础类型，具体规则在上面讲到了
- 在比较两边类型是否相等，不同类型在进行转化比较

#### 难点
##### 比较中出现false
一般在比较中出现了false的情况就比较难以理解，我们在宽松相等中看到false要记得他会转化成数字类型。
- “0” == false true
false -> 0
"0" -> 0
- false == '' true
false -> 0
'' -> 0

##### 比较中出现对象
- false == []  true
false -> 0
[].valueOf() -> []
[].toString -> ''
'' -> 0
- "" == [] // true
[].valueOf() -> []
[].toString -> ''

