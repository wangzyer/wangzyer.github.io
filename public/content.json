{"pages":[],"posts":[{"title":"","text":"容器虚拟化技术云计算当我们把各种计算机资源集中起来放到一个地方，这个地方我们就称之为云端，云计算就是对这些与那段的计算机资源进行弹性管理、分配。我们常听到的阿里云、腾讯云等都是为我们提供云计算服务。 分配资源我们平时的个人电脑cpu、内存、硬盘等都是我们买单个的硬件组装起来使用。但是如果我们从阿里云申请一台主机，他们会用一个个的硬件为我们组装起来么？显然不可能，因为不同服务对资源的要求是不一样的，并且如此多的硬件组合对资源的浪费也是庞大的。虚拟化技术在这里起到了举足轻重的地位。 什么是虚拟化虚拟化很好理解就是在一台硬件服务器上，分隔出多个虚拟服务器运行，这种虚拟服务器也叫虚拟机，这些虚拟机之前不会相互影响，每台虚拟机都有自己的内存、cpu、硬盘空间这些都是共享物理机的硬件，并且分配给每个虚拟机的硬件是相互隔离的（资源隔离），在虚拟化的时候按需求分配给各个虚拟机（资源限制）。 虚拟机和容器在使用上述的虚拟技术使用过程中会出现一些问题。如果用户只想运行一个很小的服务，为了隔离只能分隔出一个虚拟机，这个过程是比较费时的，而且如果想要迁移服务就只能迁移整个虚拟机。这时就引入了“容器”。 容器也是虚拟化，但是相对于虚拟机的虚拟化更加的轻量和快速。虚拟机是操作系统级别的隔离，同一台物理设备的虚拟机都有各自的操作系统。而容器是进程上的资源分配，还是运行在物理机的操作系统上，通过对不同进程资源的管理、分配、隔离来实现虚拟化。 从虚拟化方式的不同就可以看出容器的虚拟化速度要比虚拟机快很多。我们常听说的Docker，就是创建容器的工具，是应用容器引擎。 docker概念 Docker daemon（ Docker守护进程）：Docker daemon是一个运行在宿主机（ DOCKER-HOST）的后台进程。可通过 Docker客户端与之通信。 Client（ Docker客户端）：Docker客户端是 Docker的用户界面，它可以接受用户命令和配置标识，并与 Docker daemon通信。图中， docker build等都是 Docker的相关命令。 Images（ Docker镜像）：Docker镜像是一个只读模板，它包含创建Docker容器的说明。它和系统安装光盘有点像，使用系统安装光盘可以安装系统，同理，使用Docker镜像可以运行 Docker镜像中的程序。 Container（容器）：容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。可通过 Docker API或者 CLI命令来启停、移动、删除容器。 docker工作原理 docker的使用常用命令镜像相关 docker search jdk 搜索java相关镜像 docker pull fund-node 下载最新镜像 docker pull fund-node:1.0.0 下载指定版本的镜像 docker images 列出当前已经下载的镜像 docker rmi fund-node:1.0.0 删除镜像 docker commit -m=”update” -a=”wangzhiyong” e218edb10161 fund-node:v1.0.1 docker save fund-node:v1.0.1 &gt; fund-node.tar 导出镜像 docker load &lt; fund-node.tar 导入镜像容器相关 docker run -itd -v /data:/data node12 /bin/bash 根据指定镜像创建容器 d: 后台运行 p: 是容器内部端口绑定到指定的主机端口 it: 为容器重新分配一个伪输入终端 v: 本地和容器建立文件映射 docker ps：列出运行中的容器 a: 列出所有的容器 l: 查询最后一次创建的容器 docker stop 容器id：停止容器 docker kill 容器id：强制停止容器 docker start 容器id：启动已停止的容器 docker restart 容器id：重启停止的容器 docker inspect 容器id：查看容器的所有信息 docker top 容器id：查看容器里的进程 exit：退出容器 docker rm 容器id：删除已停止的容器 docker rm -f 容器id：删除正在运行的容器 docker container ls 列出所有的容器 docker container ls -a 列出所有的容器（包括已停止的） docker container logs 容器id：查看容器日志 docker container exec -it 容器id /bin/bash：在运行的容器中执行命令 i: 交互式操作 t: 终端 docker attach 容器ID：进入容器，退出时会停止容器（与exec功能类似） docker export 容器id &gt; some.tar 导出容器 docker import &gt; some.tar 导入容器 docker port 容器id：查看容器端口映射 k8s","link":"/2020/09/20/Docker/"},{"title":"","text":"深入JavaScript类型转换总所周知javascript是一门弱类型语言，这为我们提供了灵活行、简易性，但有时也给我们出乎意料结果，其中最多的就是类型转换。类型转换我们通常意义上分为两种，显式类型转换和隐式类型转换。这两种并没有明确的区分，通常取决于转换的隐蔽性。如果我们不理解类型转化的发生，那么会出bug，隐式类型转换也是我们经常诟病的，但是如果我们理解了所有的转换情况那么在我们眼里任何转换就都是显式转换，那么所有转化都是我们可以预料到的. 抽象操作要去理解类型转换首先要知道各个类型的转化的基础规则，在ES5中定义了一些抽象操作（仅供内部使用的操作） ToString非字符串类型至字符串类型的转换基础类型: null -&gt; “null” undefined -&gt; ‘undefined’ true -&gt; ‘true’ 100 -&gt; ‘100’ 引用类型: 普通对象会返回内部书香[[class]]（内部的分类）的值 {} -&gt; [object Object] 数组默认每一项用“，”拼接 【1，2，3】-&gt; “1，2，3” ToNumber非数字类型至数字类型的转化基础类型: true -&gt; 1 false -&gt; 0 null -&gt; 0 undefined -&gt; NaN string “123” -&gt; 123 “123a” -&gt; NaN 引用类型: 首先会被转化为基础类型，然后根据基础类型的转化规则转化 ToBoolean非布尔类型至布尔类型的转换 假值 undefined null false 0 +0 -0 NaN “” 真值 假值以外的值都是真值 ToPrimitive对象到基础类型的转化 首先调用对象valueOf方法 判断valueOf方法的返回值是不是基础类型，如果是则转化完成 如果valueOf方法返回值不是基础类型则调用toString方法 类型之间转化类型转化通常是： Object -&gt; 基础类型 基础类型 -&gt; 基础类型 其他 -&gt; Number +false ~ ~{} Number() ~运算符字位操作非运算符我们平时需要使用的场景并不多，但是在一些场景下非常好用。首先字位运算符之适用于32位整数，所以要先将操作数转化为32位整数，然后取反也就是返回操作数的补码。公式：~X = -（X+1） 类型转化~false = ~0 = -（0-1） = -1 判断除了类型转化之外，～在判断中也十分有用，我们知道0是所有数字中唯一的假值，此时应该联想到indexOf方法，我们知道indexOf返回查询字符串的位置索引，如果没有查询到则返回-1 123if('china'.indexOf('x') &gt; -1 ){....}// 可以转化成if(~'china'.indexOf('x')){...} 字位解除刚刚说过字位操作符会将操作数先转化成32位整数，所以我们可以使用它作为小数位的截取,先取反两次。 12~~34.33 // 34~~-34.33 // 34 可以看出这里是直接截取小数位的。 其他 -&gt; String转化成字符串相对比较简单 false.toString() String(false) false + ‘’ 其他 -&gt; Boolean !1 Boolean() if(…) for(…;…;…) ？： while(…) do…while(…) || &amp;&amp; 左边的表达式 Number &lt;-&gt; String数字和字符串之间的转化应该我们平时最常见的转化，所以单独提出来总结一下。 Number -&gt; String数字转化成字符串的： String(1) 根据抽象操作的ToString规则 1..toString() new Date(1571239714845) 1 + ‘’ String -&gt; Number Number() 根据抽象操作的ToNumber规则 parseInt()、parseFloat() ~’123’ +or-‘123’ new Date(‘2019/10/16’) 解析速度parseInt &gt; parseFloat &gt; Number parseInt和parseFloat是只处理字符串，任何不是字符串的值都会先转成字符串包括数字，然后在根据规则解析字符串最后返回数字，流程相对简单，并做了目的性强的优化，所以处理速度快。 Number构造函数会首先判断类型然后根据不同类型在做相应的转化，这里耗费的比较多时间，但是这些时间的耗费都是微妙级的。 Object -&gt; *对像转化成基础类根据ToPrimitive规则。toPrimitive操作会获取对象的[[Default]]。通常就是先调用valueOf()方法判断返回的时候是基础类型，是则返回，不是则调用toString()方法 123456let a = { valueOf(){ return 1 }}a + '' // '1' 在上述运算中首先需要对象a转化为基础类型，返回了1，在 1 + ‘’，返回了 ’1‘。 宽松相等和严格相等宽松相等与严格相等的区别是严格相等比较过程中不允许类型转换，宽松相等做的事情其实比严格相等更多，但是相差的时间都是几微秒。 在平时开发过程中推荐使用严格相等，使用宽松相等场景并不是很多。我平时写业务代码与后端数据交互时，返回“数字”的类型是不明确的这时我更多时使用Number类型转化一下，这样在未来阅读代码时候类型就很明确了。 虽然使用场景不多但是知道他的转换规则还是有必要，万一别人用呢。 宽松相等两种类型不同值比较时会将两边转化成同类型在进行比较，这里我们最主要的就是弄清楚各个类型比较时转化的规则 非常规情况 NaN == NaN false 不与任何值相等包括自己 -0 == +0 true null == undefined true Number和String之前比较 使用ToNumber规则将字符串转化为数字 数字之间比较 其中一方有Boolean 首先将Boolean转化为数字 false-&gt;0 true-&gt;1 在比较两边类型是否相等，不同类型在进行转化比较 对象和非对象之间的比较 首相将对象转化为基础类型，具体规则在上面讲到了 在比较两边类型是否相等，不同类型在进行转化比较 难点比较中出现false一般在比较中出现了false的情况就比较难以理解，我们在宽松相等中看到false要记得他会转化成数字类型。 “0” == false truefalse -&gt; 0“0” -&gt; 0 false == ‘’ truefalse -&gt; 0‘’ -&gt; 0 比较中出现对象 false == [] truefalse -&gt; 0[].valueOf() -&gt; [][].toString -&gt; ‘’‘’ -&gt; 0 “” == [] // true[].valueOf() -&gt; [][].toString -&gt; ‘’","link":"/2020/09/28/JavaScriptDecortors/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"NodeJs","slug":"NodeJs","link":"/tags/NodeJs/"}],"categories":[{"name":"容器","slug":"容器","link":"/categories/%E5%AE%B9%E5%99%A8/"}]}